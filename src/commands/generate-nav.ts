/**
 * @file Contains the logic for the `folio generate-nav` command.
 * This command generates comprehensive navigation files for LLM accessibility.
 */

import fs from "node:fs/promises";
import path from "node:path";
import { Command } from "commander";
import matter from "gray-matter";
import type { FolioConfig } from "../types/folio";
import { loadConfig } from "../utils/config-loader";
import log from "../utils/logging";

interface DocumentInfo {
  filename: string;
  filepath: string;
  relativePath: string;
  frontmatter: { [key: string]: any };
  title: string;
  id?: string;
  type: string;
}

/**
 * Recursively scans a directory for all markdown files
 */
async function scanDirectory(
  dir: string,
  rootDir: string,
  _docType: string = "misc",
): Promise<DocumentInfo[]> {
  const documents: DocumentInfo[] = [];

  try {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        // Recursively scan subdirectories
        const subDocs = await scanDirectory(fullPath, rootDir, _docType);
        documents.push(...subDocs);
      } else if (
        entry.isFile() &&
        (entry.name.endsWith(".md") || entry.name.endsWith(".mdx")) &&
        entry.name !== "README.md"
      ) {
        try {
          const content = await fs.readFile(fullPath, "utf-8");
          const { data, content: markdownContent } = matter(content);
          const relativePath = path.relative(rootDir, fullPath);

          // Skip files that are likely just placeholder content (very short)
          const contentLength = markdownContent.trim().length;
          if (contentLength < 50) {
            continue;
          }

          documents.push({
            filename: entry.name,
            filepath: fullPath,
            relativePath,
            frontmatter: data,
            title: data.title || entry.name.replace(/\.(md|mdx)$/, ""),
            id: data.id || data.ticket_id || data.adr_id,
            type: _docType,
          });
        } catch (_error) {
          log.warn(`Could not parse frontmatter in ${fullPath}`);
        }
      }
    }
  } catch (_error) {
    // Directory might not exist, that's okay
  }

  return documents;
}

/**
 * Generates the root README.md with comprehensive navigation
 */
async function generateRootReadme(
  config: FolioConfig,
  configDir: string,
  allDocuments: DocumentInfo[],
): Promise<void> {
  const docsRoot = path.join(configDir, config.root);
  const readmePath = path.join(docsRoot, "README.md");

  // Group documents by type for better organization
  const documentsByType = new Map<string, DocumentInfo[]>();

  for (const doc of allDocuments) {
    if (!documentsByType.has(doc.type)) {
      documentsByType.set(doc.type, []);
    }
    documentsByType.get(doc.type)?.push(doc);
  }

  // Sort documents within each type
  for (const [_type, docs] of documentsByType) {
    docs.sort((a, b) => {
      // Sort by ID if available (for tickets/ADRs), then by title
      if (a.id && b.id) {
        return String(a.id).localeCompare(String(b.id), undefined, { numeric: true });
      }
      return a.title.localeCompare(b.title);
    });
  }

  let content = `# Project Documentation

*This index is automatically generated by folio-cli for LLM accessibility and quick navigation.*

## 🚀 Quick Navigation

### By Document Type
${Array.from(documentsByType.keys())
  .map((type) => {
    const docs = documentsByType.get(type)!;
    return `- **${type.toUpperCase()}** (${docs.length} documents) → [Browse ${type}](#${type.toLowerCase().replace(/[^a-z0-9]/g, "-")})`;
  })
  .join("\n")}

### By Directory Structure
`;

  // Add directory navigation - only for directories that contain documents
  const existingDirectories = new Set<string>();
  for (const doc of allDocuments) {
    const dir = doc.relativePath.split('/')[0];
    if (dir && dir !== doc.relativePath) {
      existingDirectories.add(dir);
    }
  }

  for (const dir of Array.from(existingDirectories).sort()) {
    const dirDocs = allDocuments.filter((doc) =>
      doc.relativePath.startsWith(dir + '/'),
    );
    if (dirDocs.length > 0) {
      content += `- [📁 ${dir}](./${dir}/) (${dirDocs.length} documents)\n`;
    }
  }

  content += `\n## 🔍 Document Index\n\n`;

  // Add sections for each document type
  for (const [type, docs] of documentsByType) {
    if (docs.length === 0) continue;

    content += `### ${type.toUpperCase()}\n\n`;

    // Special handling for ADRs and tickets with IDs
    if (type === "adr" || type === "ticket") {
      content += `| ID | Title | Status | File |\n`;
      content += `|----|-------|--------|----- |\n`;

      for (const doc of docs) {
        const id = doc.id || "N/A";
        const status = doc.frontmatter.status || "unknown";
        const title = doc.title.replace(/^\\d+-/, ""); // Remove number prefix if present
        content += `| \`${id}\` | [${title}](${doc.relativePath}) | ${status} | \`${doc.filename}\` |\n`;
      }
    } else {
      // Simple list for other document types
      for (const doc of docs) {
        const description =
          doc.frontmatter.description || doc.frontmatter.summary || "";
        content += `- [**${doc.title}**](${doc.relativePath})`;
        if (description) {
          content += ` - ${description}`;
        }
        content += `\n`;
      }
    }

    content += `\n`;
  }

  // Add quick search section
  content += `## 🔎 Quick Search\n\n`;
  content += `### Find by ID\n`;
  content += `Use these patterns to quickly find documents:\n\n`;

  // Show example IDs for each type
  for (const [type, docs] of documentsByType) {
    const docsWithIds = docs.filter((doc) => doc.id);
    if (docsWithIds.length > 0) {
      const exampleIds = docsWithIds
        .slice(0, 3)
        .map((doc) => `\`${doc.id}\``)
        .join(", ");
      content += `- **${type.toUpperCase()} IDs**: ${exampleIds}${docsWithIds.length > 3 ? ", ..." : ""}\n`;
    }
  }

  content += `\n### Find by Status\n`;
  const statuses = new Set(
    allDocuments.map((doc) => doc.frontmatter.status).filter(Boolean),
  );
  if (statuses.size > 0) {
    content += `Available statuses: ${Array.from(statuses)
      .map((s) => `\`${s}\``)
      .join(", ")}\n\n`;
  }

  // Add last updated info
  content += `\n---\n*Last updated: ${new Date().toISOString().split("T")[0]} by folio-cli*\n`;

  await fs.writeFile(readmePath, content, "utf-8");
  log.info(
    `Generated root navigation: ${path.relative(configDir, readmePath)}`,
  );
}

/**
 * Generates directory-level index files
 */
async function generateDirectoryIndexes(
  config: FolioConfig,
  configDir: string,
  allDocuments: DocumentInfo[],
): Promise<void> {
  const docsRoot = path.join(configDir, config.root);

  // Get all unique directories that actually contain documents
  const directories = new Set<string>();
  for (const doc of allDocuments) {
    const dir = path.dirname(doc.relativePath);
    if (dir !== ".") {
      directories.add(dir);
    }
  }

  for (const dir of directories) {
    const dirPath = path.join(docsRoot, dir);
    const indexPath = path.join(dirPath, "README.md");

    // Get documents in this directory (not subdirectories)
    const dirDocs = allDocuments.filter(
      (doc) => path.dirname(doc.relativePath) === dir,
    );

    // Only create index if there are actual documents in this directory
    if (dirDocs.length === 0) continue;

    // Sort documents
    dirDocs.sort((a, b) => {
      if (a.id && b.id) {
        return String(a.id).localeCompare(String(b.id), undefined, { numeric: true });
      }
      return a.title.localeCompare(b.title);
    });

    let content = `# ${dir
      .split("/")
      .pop()
      ?.replace(/-/g, " ")
      .replace(/\\b\\w/g, (l) => l.toUpperCase())}\n\n`;
    content += `*This directory contains ${dirDocs.length} documents.*\n\n`;

    // Add quick navigation back to root
    const depth = dir.split("/").length;
    const backPath = "../".repeat(depth);
    content += `[← Back to Documentation Root](${backPath}README.md)\n\n`;

    content += `## Documents\n\n`;

    // Check if this looks like it contains ADRs or tickets
    const hasIds = dirDocs.some((doc) => doc.id);

    if (hasIds) {
      content += `| ID | Title | Status | File |\n`;
      content += `|----|-------|--------|----- |\n`;

      for (const doc of dirDocs) {
        const id = doc.id || "N/A";
        const status = doc.frontmatter.status || "unknown";
        const filename = path.basename(doc.relativePath);
        content += `| \`${id}\` | [${doc.title}](${filename}) | ${status} | \`${filename}\` |\n`;
      }
    } else {
      for (const doc of dirDocs) {
        const filename = path.basename(doc.relativePath);
        const description =
          doc.frontmatter.description || doc.frontmatter.summary || "";
        content += `- [**${doc.title}**](${filename})`;
        if (description) {
          content += ` - ${description}`;
        }
        content += `\n`;
      }
    }

    content += `\n---\n*Generated by folio-cli*\n`;

    await fs.writeFile(indexPath, content, "utf-8");
    log.info(
      `Generated directory index: ${path.relative(configDir, indexPath)}`,
    );
  }
}

/**
 * Handles the main logic for the 'folio generate-nav' command
 */
export async function handleGenerateNav(): Promise<void> {
  log.title("Generating Navigation Files");

  try {
    const { config, filepath } = await loadConfig();
    const configDir = path.dirname(filepath);
    const docsRoot = path.join(configDir, config.root);

    log.info("Scanning documentation files...");

    // Scan all documents
    const allDocuments: DocumentInfo[] = [];

    for (const [typeName, typeConfig] of Object.entries(config.types)) {
      const typeDir = path.join(docsRoot, typeConfig.path);
      const typeDocs = await scanDirectory(typeDir, docsRoot, typeName);
      allDocuments.push(...typeDocs);
    }

    // Scan for any additional directories that might contain documentation
    // but aren't defined as document types in the config
    try {
      const rootEntries = await fs.readdir(docsRoot, { withFileTypes: true });
      for (const entry of rootEntries) {
        if (entry.isDirectory() && !entry.name.startsWith('_')) {
          const dirPath = path.join(docsRoot, entry.name);
          
          // Skip if this directory is already covered by a document type
          const isTypedDirectory = Object.values(config.types).some(
            typeConfig => typeConfig.path.startsWith(entry.name)
          );
          
          if (!isTypedDirectory) {
            try {
              const dirDocs = await scanDirectory(
                dirPath,
                docsRoot,
                entry.name,
              );
              allDocuments.push(...dirDocs);
            } catch {
              // Error scanning directory, skip
            }
          }
        }
      }
    } catch {
      // Error reading docs root, continue with what we have
    }

    log.info(`Found ${allDocuments.length} documents`);

    // Generate root README
    await generateRootReadme(config, configDir, allDocuments);

    // Generate directory indexes
    await generateDirectoryIndexes(config, configDir, allDocuments);

    log.success(`Generated navigation for ${allDocuments.length} documents!`);
    log.info(
      "LLMs can now quickly navigate your documentation using the generated indexes.",
    );
  } catch (error) {
    log.error(
      error instanceof Error
        ? error
        : new Error("Failed to generate navigation"),
    );
    process.exit(1);
  }
}

/**
 * Creates and configures the `generate-nav` command for the Folio CLI.
 */
export function createGenerateNavCommand(): Command {
  const cmd = new Command("generate-nav");

  cmd
    .description(
      "Generate comprehensive navigation files for LLM accessibility",
    )
    .action(handleGenerateNav);

  return cmd;
}
