/**
 * @file Contains the logic for the `folio generate-nav` command.
 * This command generates comprehensive navigation files for LLM accessibility.
 */

import fs from "node:fs/promises";
import path from "node:path";
import { Command } from "commander";
import matter from "gray-matter";
import type { FolioConfig } from "../types/folio";
import { loadConfig } from "../utils/config-loader";
import log from "../utils/logging";

interface DocumentInfo {
  filename: string;
  filepath: string;
  relativePath: string;
  frontmatter: { [key: string]: any };
  title: string;
  id?: string;
  type: string;
}

/**
 * Recursively scans a directory for all markdown files
 */
async function scanDirectory(
  dir: string,
  rootDir: string,
  _docType: string = "misc",
): Promise<DocumentInfo[]> {
  const documents: DocumentInfo[] = [];

  try {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        // Recursively scan subdirectories
        const subDocs = await scanDirectory(fullPath, rootDir, _docType);
        documents.push(...subDocs);
      } else if (
        entry.isFile() &&
        (entry.name.endsWith(".md") || entry.name.endsWith(".mdx")) &&
        entry.name !== "index.md"
      ) {
        try {
          const content = await fs.readFile(fullPath, "utf-8");
          const { data } = matter(content);
          const relativePath = path.relative(rootDir, fullPath);

          documents.push({
            filename: entry.name,
            filepath: fullPath,
            relativePath,
            frontmatter: data,
            title: data.title || entry.name.replace(/\.(md|mdx)$/, ""),
            id: data.id || data.ticket_id || data.adr_id,
            type: _docType,
          });
        } catch (_error) {
          log.warn(`Could not parse frontmatter in ${fullPath}`);
        }
      }
    }
  } catch (_error) {
    // Directory might not exist, that's okay
  }

  return documents;
}

/**
 * Generates the root README.md with comprehensive navigation
 */
async function generateRootReadme(
  config: FolioConfig,
  configDir: string,
  allDocuments: DocumentInfo[],
): Promise<void> {
  const docsRoot = path.join(configDir, config.root);
  const readmePath = path.join(docsRoot, "README.md");

  // Group documents by type for better organization
  const documentsByType = new Map<string, DocumentInfo[]>();

  for (const doc of allDocuments) {
    if (!documentsByType.has(doc.type)) {
      documentsByType.set(doc.type, []);
    }
    documentsByType.get(doc.type)?.push(doc);
  }

  // Sort documents within each type
  for (const [_type, docs] of documentsByType) {
    docs.sort((a, b) => {
      // Sort by ID if available (for tickets/ADRs), then by title
      if (a.id && b.id) {
        return a.id.localeCompare(b.id, undefined, { numeric: true });
      }
      return a.title.localeCompare(b.title);
    });
  }

  let content = `# Project Documentation

*This index is automatically generated by folio-cli for LLM accessibility and quick navigation.*

## ðŸš€ Quick Navigation

### By Document Type
${Array.from(documentsByType.keys())
  .map((type) => {
    const docs = documentsByType.get(type)!;
    return `- **${type.toUpperCase()}** (${docs.length} documents) â†’ [Browse ${type}](#${type.toLowerCase().replace(/[^a-z0-9]/g, "-")})`;
  })
  .join("\n")}

### By Directory Structure
`;

  // Add directory navigation
  const directories = [
    "00-vision-and-strategy",
    "01-product-and-planning",
    "02-architecture-and-design",
    "03-engineering",
    "04-devops-and-infrastructure",
    "05-operations-and-support",
    "06-sprint-tickets",
  ];

  for (const dir of directories) {
    const dirPath = path.join(docsRoot, dir);
    try {
      await fs.access(dirPath);
      const dirDocs = allDocuments.filter((doc) =>
        doc.relativePath.startsWith(dir),
      );
      content += `- [ðŸ“ ${dir}](./${dir}/) (${dirDocs.length} documents)\n`;
    } catch {
      // Directory doesn't exist
    }
  }

  content += `\n## ðŸ” Document Index\n\n`;

  // Add sections for each document type
  for (const [type, docs] of documentsByType) {
    if (docs.length === 0) continue;

    content += `### ${type.toUpperCase()}\n\n`;

    // Special handling for ADRs and tickets with IDs
    if (type === "adr" || type === "ticket") {
      content += `| ID | Title | Status | File |\n`;
      content += `|----|-------|--------|----- |\n`;

      for (const doc of docs) {
        const id = doc.id || "N/A";
        const status = doc.frontmatter.status || "unknown";
        const title = doc.title.replace(/^\\d+-/, ""); // Remove number prefix if present
        content += `| \`${id}\` | [${title}](${doc.relativePath}) | ${status} | \`${doc.filename}\` |\n`;
      }
    } else {
      // Simple list for other document types
      for (const doc of docs) {
        const description =
          doc.frontmatter.description || doc.frontmatter.summary || "";
        content += `- [**${doc.title}**](${doc.relativePath})`;
        if (description) {
          content += ` - ${description}`;
        }
        content += `\n`;
      }
    }

    content += `\n`;
  }

  // Add quick search section
  content += `## ðŸ”Ž Quick Search\n\n`;
  content += `### Find by ID\n`;
  content += `Use these patterns to quickly find documents:\n\n`;

  // Show example IDs for each type
  for (const [type, docs] of documentsByType) {
    const docsWithIds = docs.filter((doc) => doc.id);
    if (docsWithIds.length > 0) {
      const exampleIds = docsWithIds
        .slice(0, 3)
        .map((doc) => `\`${doc.id}\``)
        .join(", ");
      content += `- **${type.toUpperCase()} IDs**: ${exampleIds}${docsWithIds.length > 3 ? ", ..." : ""}\n`;
    }
  }

  content += `\n### Find by Status\n`;
  const statuses = new Set(
    allDocuments.map((doc) => doc.frontmatter.status).filter(Boolean),
  );
  if (statuses.size > 0) {
    content += `Available statuses: ${Array.from(statuses)
      .map((s) => `\`${s}\``)
      .join(", ")}\n\n`;
  }

  // Add last updated info
  content += `\n---\n*Last updated: ${new Date().toISOString().split("T")[0]} by folio-cli*\n`;

  await fs.writeFile(readmePath, content, "utf-8");
  log.info(
    `Generated root navigation: ${path.relative(configDir, readmePath)}`,
  );
}

/**
 * Generates directory-level index files
 */
async function generateDirectoryIndexes(
  config: FolioConfig,
  configDir: string,
  allDocuments: DocumentInfo[],
): Promise<void> {
  const docsRoot = path.join(configDir, config.root);

  // Get all unique directories
  const directories = new Set<string>();
  for (const doc of allDocuments) {
    const dir = path.dirname(doc.relativePath);
    if (dir !== ".") {
      directories.add(dir);
    }
  }

  for (const dir of directories) {
    const dirPath = path.join(docsRoot, dir);
    const indexPath = path.join(dirPath, "README.md");

    // Get documents in this directory
    const dirDocs = allDocuments.filter(
      (doc) => path.dirname(doc.relativePath) === dir,
    );

    if (dirDocs.length === 0) continue;

    // Sort documents
    dirDocs.sort((a, b) => {
      if (a.id && b.id) {
        return a.id.localeCompare(b.id, undefined, { numeric: true });
      }
      return a.title.localeCompare(b.title);
    });

    let content = `# ${dir
      .split("/")
      .pop()
      ?.replace(/-/g, " ")
      .replace(/\\b\\w/g, (l) => l.toUpperCase())}\n\n`;
    content += `*This directory contains ${dirDocs.length} documents.*\n\n`;

    // Add quick navigation back to root
    const depth = dir.split("/").length;
    const backPath = "../".repeat(depth);
    content += `[â† Back to Documentation Root](${backPath}README.md)\n\n`;

    content += `## Documents\n\n`;

    // Check if this looks like it contains ADRs or tickets
    const hasIds = dirDocs.some((doc) => doc.id);

    if (hasIds) {
      content += `| ID | Title | Status | File |\n`;
      content += `|----|-------|--------|----- |\n`;

      for (const doc of dirDocs) {
        const id = doc.id || "N/A";
        const status = doc.frontmatter.status || "unknown";
        const filename = path.basename(doc.relativePath);
        content += `| \`${id}\` | [${doc.title}](${filename}) | ${status} | \`${filename}\` |\n`;
      }
    } else {
      for (const doc of dirDocs) {
        const filename = path.basename(doc.relativePath);
        const description =
          doc.frontmatter.description || doc.frontmatter.summary || "";
        content += `- [**${doc.title}**](${filename})`;
        if (description) {
          content += ` - ${description}`;
        }
        content += `\n`;
      }
    }

    content += `\n---\n*Generated by folio-cli*\n`;

    await fs.writeFile(indexPath, content, "utf-8");
    log.info(
      `Generated directory index: ${path.relative(configDir, indexPath)}`,
    );
  }
}

/**
 * Handles the main logic for the 'folio generate-nav' command
 */
export async function handleGenerateNav(): Promise<void> {
  log.title("Generating Navigation Files");

  try {
    const { config, filepath } = await loadConfig();
    const configDir = path.dirname(filepath);
    const docsRoot = path.join(configDir, config.root);

    log.info("Scanning documentation files...");

    // Scan all documents
    const allDocuments: DocumentInfo[] = [];

    for (const [typeName, typeConfig] of Object.entries(config.types)) {
      const typeDir = path.join(docsRoot, typeConfig.path);
      const typeDocs = await scanDirectory(typeDir, docsRoot, typeName);
      allDocuments.push(...typeDocs);
    }

    // Also scan other directories
    const otherDirectories = [
      "00-vision-and-strategy",
      "01-product-and-planning",
      "03-engineering",
      "04-devops-and-infrastructure",
      "05-operations-and-support",
      "06-sprint-tickets",
      "prompts",
      "schemas",
    ];

    for (const dir of otherDirectories) {
      const dirPath = path.join(docsRoot, dir);
      try {
        const dirDocs = await scanDirectory(
          dirPath,
          docsRoot,
          path.basename(dir),
        );
        allDocuments.push(...dirDocs);
      } catch {
        // Directory doesn't exist, skip
      }
    }

    log.info(`Found ${allDocuments.length} documents`);

    // Generate root README
    await generateRootReadme(config, configDir, allDocuments);

    // Generate directory indexes
    await generateDirectoryIndexes(config, configDir, allDocuments);

    log.success(`Generated navigation for ${allDocuments.length} documents!`);
    log.info(
      "LLMs can now quickly navigate your documentation using the generated indexes.",
    );
  } catch (error) {
    log.error(
      error instanceof Error
        ? error
        : new Error("Failed to generate navigation"),
    );
    process.exit(1);
  }
}

/**
 * Creates and configures the `generate-nav` command for the Folio CLI.
 */
export function createGenerateNavCommand(): Command {
  const cmd = new Command("generate-nav");

  cmd
    .description(
      "Generate comprehensive navigation files for LLM accessibility",
    )
    .action(handleGenerateNav);

  return cmd;
}
